import os
import json
import re
import time
from datetime import datetime, timedelta
from typing import List, Dict
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options


def get_target_date(days_ago=1):
    """L·∫•y ng√†y YYYY-MM-DD c·ªßa h√¥m qua (ho·∫∑c n ng√†y tr∆∞·ªõc)"""
    target_date = datetime.now() - timedelta(days=days_ago)
    return target_date.strftime("%Y")
class ScholarFinder:
    def __init__(self):
        self.driver = None

    def setup_browser(self):
        """Setup Chrome/Chromium cho m√¥i tr∆∞·ªùng headless tr√™n GitHub Actions"""
        options = Options()
        options.add_argument("--headless=new")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--disable-gpu")
        options.add_argument("--disable-extensions")
        options.add_argument("--window-size=1920,1080")
        options.add_argument("--remote-debugging-port=9222")
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_argument("--lang=en-US")
        options.add_argument("--user-data-dir=/tmp/chrome-profile")

        # üß© Gi·∫£ l·∫≠p user-agent th·∫≠t
        options.add_argument(
            "--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
            "AppleWebKit/537.36 (KHTML, like Gecko) "
            "Chrome/122.0.6261.129 Safari/537.36"
        )

        # ‚úÖ Chromium binary tr√™n Ubuntu
        options.binary_location = "/usr/bin/chromium-browser"

        from selenium.webdriver.chrome.service import Service
        service = Service("/usr/bin/chromedriver")

        self.driver = webdriver.Chrome(service=service, options=options)

        # ·∫®n navigator.webdriver
        self.driver.execute_cdp_cmd(
            "Page.addScriptToEvaluateOnNewDocument",
            {"source": "Object.defineProperty(navigator, 'webdriver', {get: () => undefined})"}
        )

        # üîπ M·ªü Google Scholar th·ªß c√¥ng, ki·ªÉm tra c√≥ redirect kh√¥ng
        self.driver.get("https://scholar.google.com/")
        time.sleep(5)
        current_url = self.driver.current_url
        page_source = self.driver.page_source[:500].lower()

        if "sorry" in page_source or "unusual traffic" in page_source:
            print("‚ö†Ô∏è Google Scholar detected bot or CAPTCHA. Switching to safer user-agent.")
            self.driver.quit()
            # D·ª´ng s·ªõm ƒë·ªÉ tr√°nh loop v√¥ h·∫°n
            raise RuntimeError("Google Scholar blocked the request (CAPTCHA detected).")

        print("‚úÖ Chrome driver kh·ªüi ƒë·ªông v√† truy c·∫≠p Google Scholar th√†nh c√¥ng")
        return self.driver



    def extract_pub_date(self, authors_text: str):
        """
        L·∫•y nƒÉm xu·∫•t b·∫£n t·ª´ chu·ªói th√¥ng tin t√°c gi·∫£ tr√™n Google Scholar
        """
        year_match = re.search(r'\b(19|20)\d{2}\b', authors_text)
        if year_match:
            return year_match.group(0)
        return "Not Available"

    def get_paper_details_from_link(self, paper_url: str, paper_rank: int) -> Dict:
        """
        M·ªü link b√†i b√°o ƒë·ªÉ l·∫•y ƒë·∫ßy ƒë·ªß title v√† abstract
        """
        print(f"Accessing paper {paper_rank}: {paper_url}")
        try:
            self.driver.execute_script("window.open('');")
            self.driver.switch_to.window(self.driver.window_handles[-1])
            self.driver.get(paper_url)
            time.sleep(4)

            title = "Not Available"
            abstract = "Not Available"

            # Title selectors
            title_selectors = [
                "h1", "h2", ".title", "#title",
                "h1[class*='title']", "h2[class*='title']",
                ".paper-title", ".article-title",
                ".entry-title", ".post-title"
            ]
            for selector in title_selectors:
                try:
                    title_element = self.driver.find_element(By.CSS_SELECTOR, selector)
                    if title_element.text.strip() and len(title_element.text.strip()) > 10:
                        title = title_element.text.strip()
                        break
                except:
                    continue

            # Abstract selectors
            abstract_selectors = [
                ".abstract", "#abstract", "[class*='abstract']",
                ".summary", "#summary", "[class*='summary']",
                "p[class*='abstract']", "div[class*='abstract']",
                ".paper-abstract", ".article-abstract",
                "section[class*='abstract']", "[id*='abstract']"
            ]
            for selector in abstract_selectors:
                try:
                    abstract_element = self.driver.find_element(By.CSS_SELECTOR, selector)
                    if abstract_element.text.strip() and len(abstract_element.text.strip()) > 50:
                        abstract = abstract_element.text.strip()
                        break
                except:
                    continue

            # N·∫øu v·∫´n ch∆∞a t√¨m th·∫•y abstract -> th·ª≠ t√¨m trong c√°c ƒëo·∫°n vƒÉn d√†i
            if abstract == "Not Available":
                try:
                    paragraphs = self.driver.find_elements(By.TAG_NAME, "p")
                    for p in paragraphs:
                        text = p.text.strip()
                        if len(text) > 100 and any(word in text.lower() for word in
                                                    ['abstract', 'this paper', 'this study', 'we present', 'we propose']):
                            abstract = text
                            break
                except:
                    pass

            # ƒê√≥ng tab hi·ªán t·∫°i, quay v·ªÅ tab ch√≠nh
            self.driver.close()
            self.driver.switch_to.window(self.driver.window_handles[0])

            return {
                "title": title,
                "abstract": abstract,
                "url": paper_url,
                "access_status": "success" if title != "Not Available" else "failed"
            }

        except Exception as e:
            print(f"Error accessing paper {paper_rank}: {e}")
            try:
                if len(self.driver.window_handles) > 1:
                    self.driver.close()
                    self.driver.switch_to.window(self.driver.window_handles[0])
            except:
                pass
            return {
                "title": "Error accessing paper",
                "abstract": f"Error: {str(e)}",
                "url": paper_url,
                "access_status": "error"
            }

    def search_google_scholar(self, search_query: str, max_papers: int = 20, date: str = None) -> List[Dict]:
        """
        T√¨m ki·∫øm Google Scholar v√† tr·∫£ v·ªÅ danh s√°ch b√†i b√°o m·ªõi nh·∫•t,
        ch·ªâ l·∫•y ƒë√∫ng ng√†y (n·∫øu c√≥ date).
        """
        print(f"Searching Google Scholar for: {search_query}")
        self.driver.get("https://scholar.google.com")
        time.sleep(3)

        # Nh·∫≠p t·ª´ kh√≥a
        search_box = WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located((By.NAME, "q"))
        )
        search_box.clear()
        search_box.send_keys(search_query)
        self.driver.find_element(By.XPATH, "//button[@type='submit']").click()
        time.sleep(4)

        # Click "Sort by date"
        try:
            sort_by_date_button = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located(
                    (By.XPATH, "//a[normalize-space(text())='S·∫Øp x·∫øp theo ng√†y' or normalize-space(text())='Sort by date']")
                )
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", sort_by_date_button)
            time.sleep(1)
            self.driver.execute_script("arguments[0].click();", sort_by_date_button)
            time.sleep(2)
            print("‚úî ƒê√£ click 'S·∫Øp x·∫øp theo ng√†y'")
        except Exception as e:
            print(f"‚ö† Kh√¥ng click ƒë∆∞·ª£c 'S·∫Øp x·∫øp theo ng√†y': {e}")

        papers = []
        results = self.driver.find_elements(By.CSS_SELECTOR, "div.gs_r.gs_or.gs_scl")[:max_papers]
        print(f"Found {len(results)} papers to process")

        for idx, result in enumerate(results, 1):
            try:
                title_element = result.find_element(By.CSS_SELECTOR, "h3.gs_rt a")
                link = title_element.get_attribute("href")
                basic_title = title_element.text

                try:
                    authors_text = result.find_element(By.CSS_SELECTOR, "div.gs_a").text
                except:
                    authors_text = "Authors not found"

                pub_date = self.extract_pub_date(authors_text)

                # üîπ L·ªçc theo ng√†y (n·∫øu c√≥ y√™u c·∫ßu)
                if date and pub_date != date:
                    print(f"‚úò B·ªè qua paper {idx} v√¨ nƒÉm {pub_date} kh√°c {date}")
                    continue

                try:
                    citation_element = result.find_element(By.XPATH, ".//a[contains(text(), 'Cited by')]")
                    citations = citation_element.text.replace("Cited by ", "")
                except:
                    citations = 0

                full_details = self.get_paper_details_from_link(link, idx)

                paper = {
                    "source": "Google Scholar",
                    "title": full_details['title'],
                    "abstract": full_details['abstract'],
                    "authors": authors_text,
                    "link": link,
                    "citations": citations,
                    "status": "Open Access",
                    "pub_date": pub_date
                }

                papers.append(paper)
                print(f"‚úì Processed paper {idx}: {paper['title'][:80]}")
                time.sleep(3)

            except Exception as e:
                print(f"Error processing paper {idx}: {e}")
                continue

        print(f"\n=== Successfully processed {len(papers)} papers ===")
        return papers

    def run(self, keyword: str, max_papers: int = 100, date: str = None):
        self.setup_browser()
        try:
            return self.search_google_scholar(keyword, max_papers, date)
        finally:
            if self.driver:
                self.driver.quit()


def run_scholar_search(keyword: str, max_papers: int = 100):
    finder = ScholarFinder()
    date_str = get_target_date(days_ago=1)
    return finder.run(keyword, max_papers, date=date_str)




